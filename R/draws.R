#' @title Fit the base imputation model and get parameter estimates
#'
#' @description Assuming MAR, `draws` fits the base imputation model to the observed data
#' according to the given multiple imputation methodology and returns the parameter
#' estimates from the fit.
#'
#' @name draws
#' @param data A `data.frame` containing the data to be used in the model.
#' Must contain the outcome variable. See details.
#' @param data_ice A `data.frame` that specifies the information related
#' to the intercurrent events (ICE) and the imputation strategies. Its structure is described in the details.
#' @param vars A `vars` object as generated by [set_vars()]. See details.
#' @param method An object returned by the functions [method_bayes()],
#' [method_approxbayes()] or [method_condmean()].
#' It specifies the multiple imputation methodology to be used. See details.
#'
#' @details
#'
#' `draws` performs the first step of the multiple imputation (MI) procedure: the fit of the
#' base imputation model. The goal is to estimate the parameters of interest needed
#' for the imputation phase (i.e. the regression coefficients and the covariance matrices
#' from a MMRM model).
#'
#' The function distinguishes between the following methods:
#' - Bayesian MI based on MCMC sampling: `draws` returns the draws
#' from the posterior distribution of the parameters using a Bayesian approach based on
#' MCMC sampling. This method can be adopted by specifying `method` using [method_bayes()].
#' - Approximate Bayesian MI based on bootstrap: `draws` returns
#' the draws from the posterior distribution of the parameters using a Bayesian approach,
#' where the sampling from the posterior distribution is simulated fitting the MMRM model
#' on bootstrap samples of the original dataset. This method can be adopted by
#' specifying `method` through [method_approxbayes()].
#' - Conditional mean imputation with bootstrap re-sampling: `draws` returns the
#' ML/REML parameter estimates from the original dataset and from `n_samples` bootstrap samples.
#' This method can be adopted by specifying `method` through [method_condmean()] with
#' argument `type = "bootstrap"`.
#' - Conditional mean imputation with Jackknife re-sampling: `draws` returns the
#' ML/REML parameter estimates from the original dataset and from the leave-one-out samples.
#' This method can be adopted by specifying `method` through [method_condmean()] with
#' argument `type = "jackknife"`.
#'
#' The argument `data` must have one row per visit per subject. This means that incomplete
#' outcome data must be set as `NA` instead of having the related row missing. Missing values
#' in the covariates are not allowed. If `data` is incomplete
#' then the [expand_locf()] helper function can be used to add in any missing rows, using
#' Last Observation Carried Forward (LOCF) imputation to impute the covariates values.
#'
#' The argument `data_ice` contains information about the occurrence of ICEs. It is a
#' `data.frame` with 3 columns:
#' - A vector of characters related to the ids of the subjects that experienced
#'   the ICE (must be named as `vars$subjid`).
#' - A vector of levels of `data[[vars$visit]]` including the first visit after the ICE (must be named as `vars$visit`). If
#'   multiple ICEs happen for the same subject, then only the first non-MAR visit should be set.
#' - A vector of characters related to the imputation strategy to address the ICE (must be named as `vars$strategy`).
#'   Possible imputation strategies are:
#'   - `"MAR"`: Missing At Random.
#'   - `"JTR"`: Jump To Reference.
#'   - `"CIR"`: Copy Increments in Reference.
#'   - `"CR"`: Copy Reference.
#'   - `"JR"`: Jump to Reference.
#'   - `"LMCF"`: Last Mean Carried Forward.
#'   - Customized imputation strategies can also be set.
#'
#' This argument is necessary at this stage since the model will be fit only on those observed data
#' that, if missing, would be characterized as MAR. Thus, any non-MAR observed data, i.e.
#' any observed data after `data_ice[[vars$visit]]` that is addressed with an imputation
#' strategy different from MAR will be discarded for the model fit. Such observed data
#' however will not be discarded from the data in the imputation phase
#' (performed with the function ([impute()]).
#'
#' The argument `vars` is a named list of key variable names to specify
#' the imputation model. Can be set using [set_vars()] providing the following arguments:
#' - `subjid`: column in `data` related to the subject ids variable.
#' - `visit`: column in `data` related to the visit variable.
#' - `outcome`: column in `data` related to the outcome variable.
#' - `group`: column in `data` related to the group variable.
#' - `covariates`: vector of characters related to the covariates to be included
#'   in the model (including interactions).
#'   By default the model specification is `outcome ~ 1 + visit + group`.
#'   Please note that the `group*visit` interaction
#'   is **not** included in the model by default.
#' - `strata`: covariates used as stratification variables in the bootstrap.
#'   By default only the `vars$group` is used as stratification variable.
#'   Needed only for `method_condmean(type = "bootstrap")` and `method_approxbayes()`.
#' - `strategy`: column in `data_ice` related to the subject-specific imputation strategy.
#'
#' @return A named list containing the following:
#' - `data`: R6 class object containing all relevant input data information.
#' - `method`: named list containing summary information of the chosen MI approach.
#' - `samples`: list containing the estimated parameters of interest.
#'   Each element of `samples` is a named list containing the following:
#'   - `ids`: vector of characters containing the ids of the subjects included in the original dataset.
#'   - `beta`: numeric vector of estimated regression coefficients.
#'   - `sigma`: list of estimated covariance matrices (one for each level of `vars$group`).
#'   - `theta`: numberic vector of transformed covariances.
#'   - `failed`: Logical. `TRUE` if the model fit failed.
#'   - `ids_samp`: vector of characters containing the ids of the subjects included in the given sample.
#' - `fit`: if `method_bayes()` is chosen, returns the MCMC Stan fit object. Otherwise `NULL`.
#' - `n_failures`: absolute number of failures of the model fit.
#' Relevant only for `method_condmean(type = "bootstrap")` and `method_approxbayes()`.
#' - `formula`: fixed effects formula object used for the model specification.
#'
#' For more details see the quickstart vignette:
#' \code{vignette("quickstart", package = "rbmi")}.
#'
#'@seealso [method_bayes()], [method_approxbayes()], [method_condmean()] for setting `method`.
#'@seealso [set_vars()] for setting `vars`.
#'@seealso [expand_locf()] for expanding `data` in case of missing rows.
#'
#' @export
draws <- function(data, data_ice, vars, method) {
    UseMethod("draws", method)
}




#' @rdname draws
#' @export
draws.approxbayes <- function(data, data_ice, vars, method) {
    longdata <- longDataConstructor$new(data, vars)
    longdata$set_strategies(data_ice)
    x <- get_bootstrap_draws(longdata, method, use_samp_ids = FALSE, first_sample_orig = FALSE)
    return(x)
}


#' @rdname draws
#' @export
draws.condmean <- function(data, data_ice, vars, method) {
    longdata <- longDataConstructor$new(data, vars)
    longdata$set_strategies(data_ice)
    if (method$type == "bootstrap") {
        x <- get_bootstrap_draws(longdata, method, use_samp_ids = TRUE, first_sample_orig = TRUE)
    } else if (method$type == "jackknife") {
        x <- get_jackknife_draws(longdata, method)
    } else {
        stop("Unknown method type")
    }
    return(x)
}


#' TODO
#'
#' @description
#' TODO
#'
#' @param longdata TODO
#' @param method TODO
#' @param use_samp_ids TODO
#' @param first_sample_orig TODO
get_bootstrap_draws <- function(
    longdata,
    method,
    use_samp_ids = FALSE,
    first_sample_orig = FALSE
) {
    n_samples <- ife(first_sample_orig, method$n_samples + 1, method$n_samples)

    samples <- vector("list", length = n_samples)
    current_sample <- 1
    failed_samples <- 0
    failure_limit <- ceiling(method$threshold * n_samples)

    initial_sample <- get_mmrm_sample(
        ids = longdata$ids,
        longdata = longdata,
        method = method,
        optimizer = c("L-BFGS-B", "BFGS")
    )

    if (initial_sample$failed) {
        stop("Fitting MMRM to original dataset failed")
    }

    optimizer <- list(
        "L-BFGS-B" = NULL,
        "BFGS" = initial_sample[c("beta", "theta")]
    )

    if (first_sample_orig) {
        samples[[1]] <- initial_sample
        current_sample <- current_sample + 1
    }

    while (current_sample <= n_samples & failed_samples <= failure_limit) {

        ids_boot <- longdata$sample_ids()
        sample_boot <- get_mmrm_sample(
            ids = ids_boot,
            longdata = longdata,
            method = method,
            optimizer = optimizer
        )

        if (sample_boot$failed) {
            failed_samples <- failed_samples + 1
            if (failed_samples > failure_limit) {
                msg <- "More than %s failed fits. Try using a simpler covariance structure"
                stop(sprintf(msg, failure_limit))
            }
        } else {
            if (!use_samp_ids) {
                sample_boot$ids <- longdata$ids
            }
            samples[[current_sample]] <- sample_boot
            current_sample <- current_sample + 1
        }
    }
    ret <- as_draws(
        method = method,
        samples = as_sample_list(samples),
        data = longdata,
        formula = as_simple_formula(longdata$vars),
        n_failures = failed_samples
    )
    return(ret)
}


#' Title
#'
#' @param longdata TODO
#' @param method TODO
get_jackknife_draws <- function(longdata, method) {

    ids <- longdata$ids
    samples <- vector("list", length = length(ids) + 1)

    samples[[1]] <- get_mmrm_sample(
        ids = ids,
        longdata = longdata,
        method = method,
        optimizer = c("L-BFGS-B", "BFGS")
    )

    optimizer <- list(
        "L-BFGS-B" = NULL,
        "BFGS" = samples[[1]][c("beta", "theta")]
    )

    ids_jack <- lapply(seq_along(ids), function(i) ids[-i])

    for (i in seq_along(ids)) {
        ids_jack <- ids[-i]
        sample <- get_mmrm_sample(
            ids = ids_jack,
            longdata = longdata,
            method = method,
            optimizer = optimizer
        )
        if (sample$failed) {
            stop("Jackknife sample failed")
        }
        samples[[i + 1]] <- sample
    }
    ret <- as_draws(
        method = method,
        samples = as_sample_list(samples),
        data = longdata,
        formula = as_simple_formula(longdata$vars),
        n_failures = 0
    )
    return(ret)
}


#' TODO
#'
#' @description
#' TODO
#'
#' @param ids TODO
#' @param longdata TODO
#' @param method TODO
#' @param optimizer TODO
get_mmrm_sample <- function(ids, longdata, method, optimizer) {

    vars <- longdata$vars
    dat <- longdata$get_data(ids, nmar.rm = TRUE, na.rm = TRUE)
    model_df <- as_model_df(dat, as_simple_formula(vars))

    sample <- fit_mmrm_multiopt(
        designmat = model_df[, -1, drop = FALSE],
        outcome = as.data.frame(model_df)[, 1],
        subjid = dat[[vars$subjid]],
        visit = dat[[vars$visit]],
        group = dat[[vars$group]],
        cov_struct = method$covariance,
        REML = method$REML,
        same_cov = method$same_cov,
        optimizer = optimizer
    )

    if (sample$failed) {
        ret <- as_sample_single(
            ids = ids,
            failed = TRUE
        )
    } else {
        ret <- as_sample_single(
            ids = ids,
            failed = FALSE,
            beta = sample$beta,
            sigma = sample$sigma,
            theta = sample$theta
        )
    }
    return(ret)
}


#' Title - TODO
#'
#' @param longdata TODO
extract_data_nmar_as_na <- function(longdata) {
    # remove non-MAR data
    data <- longdata$get_data(longdata$ids, nmar.rm = FALSE, na.rm = FALSE)
    is_mar <- unlist(longdata$is_mar)
    data[!is_mar, longdata$vars$outcome] <- NA
    return(data)
}


#' @rdname draws
#' @export
draws.bayes <- function(data, data_ice, vars, method) {

    if (!is.na(method$seed)) {
        set.seed(method$seed)
    }

    longdata <- longDataConstructor$new(data, vars)
    longdata$set_strategies(data_ice)

    data2 <- extract_data_nmar_as_na(longdata)

    # compute design matrix
    frm <- as_simple_formula(vars)
    model_df <- as_model_df(data2, frm)

    # scale input data
    scaler <- scalerConstructor$new(model_df)
    model_df_scaled <- scaler$scale(model_df)

    fit <- fit_mcmc(
        designmat = model_df_scaled[, -1, drop = FALSE],
        outcome = model_df_scaled[, 1, drop = TRUE],
        group = data2[[vars$group]],
        visit = data2[[vars$visit]],
        subjid = data2[[vars$subjid]],
        n_imputations = method$n_samples,
        burn_in = method$burn_in,
        seed = method$seed,
        burn_between = method$burn_between,
        same_cov = method$same_cov,
        verbose = method$verbose
    )

    # set names of covariance matrices
    fit$samples$sigma <- lapply(
        fit$samples$sigma,
        function(sample_cov) {
            lvls <- levels(data2[[vars$group]])
            sample_cov <- ife(
                method$same_cov == TRUE,
                rep(sample_cov, length(lvls)),
                sample_cov
            )
            setNames(sample_cov, lvls)
        }
    )

    # unscale samples
    samples <- mapply(
        function(x, y) list("beta" = x, "sigma" = y),
        lapply(fit$samples$beta, scaler$unscale_beta),
        lapply(fit$samples$sigma, function(covs) lapply(covs, scaler$unscale_sigma)),
        SIMPLIFY = FALSE
    )

    # set ids associated to each sample
    samples <- lapply(
        samples,
        function(x) {
            as_sample_single(
                ids = longdata$ids,
                beta = x$beta,
                sigma = x$sigma,
                failed = FALSE
            )
        }
    )

    result <- as_draws(
        method = method,
        samples = as_sample_list(samples),
        data = longdata,
        fit = fit$fit,
        formula = frm,
        n_failures = 0
    )

    return(result)
}




#' Print Draws Object
#'
#' @param x A draws object generated by [draws()]
#' @param ... not used
#' @export
print.draws <- function(x, ...) {

    frm <- as.character(x$formula)
    frm_str <- sprintf("%s ~ %s", frm[[2]], frm[[3]])

    meth <- switch(
         class(x$method)[[2]],
         "approxbayes" = "Approximate Bayes",
         "condmean" = "Conditional Mean",
         "bayes" = "Bayes"
    )

    meth_args <- vapply(
        mapply(
            function(x, y) sprintf("    %s: %s", y, x),
            x$method,
            names(x$method),
            USE.NAMES = FALSE,
            SIMPLIFY = FALSE
        ),
        identity,
        character(1)
    )

    n_samp <- length(x$samples)
    n_samp_string <- ife(
        has_class(x$method, "condmean"),
        sprintf("1 + %s", n_samp - 1),
        as.character(n_samp)
    )

    string <- c(
        "",
        "Draws Object",
        "------------",
        sprintf("Number of Samples: %s", n_samp_string),
        sprintf("Number of Failed Samples: %s", x$n_failures),
        sprintf("Model Formula: %s", frm_str),
        sprintf("Imputation Type: %s", class(x)[[2]]),
        "Method:",
        sprintf("    Type: %s", meth),
        meth_args,
        ""
    )

    cat(string, sep = "\n")
    return(invisible(x))
}




#' TODO
#'
#' @description
#' TODO
#'
#' @param ids TODO
#' @param beta TODO
#' @param sigma TODO
#' @param theta TODO
#' @param failed TODO
#' @param ids_samp TODO
as_sample_single <- function(
    ids,
    beta = NA,
    sigma = NA,
    theta = NA,
    failed = any(is.na(beta)),
    ids_samp = ids
) {
    x <- list(
        ids = ids,
        failed = failed,
        beta = beta,
        sigma = sigma,
        theta = theta,
        ids_samp = ids_samp
    )
    class(x) <- c("sample_single", "list")
    validate(x)
    return(x)
}


#' @export
validate.sample_single <- function(x, ...) {

    assert_that(
        x$failed %in% c(TRUE, FALSE),
        is.character(x$ids),
        length(x$ids) > 1,
        is.character(x$ids_samp),
        length(x$ids_samp) > 1
    )

    if (x$failed == TRUE) {
        assert_that(
            is.na(x$beta),
            is.na(x$sigma),
            is.na(x$theta)
        )
    } else {
        assert_that(
            is.numeric(x$beta),
            all(!is.na(x$beta)),
            is.list(x$sigma),
            !is.null(names(x$sigma)),
            all(vapply(x$sigma, is.matrix, logical(1)))
        )
    }
}


#' TODO
#'
#' @description
#' TODO
#'
#' @param ... TODO
as_sample_list <- function(...) {
    x <- list(...)
    if (length(x) == 1 & class(x[[1]])[[1]] != "sample_single") {
        x <- x[[1]]
    }
    class(x) <- c("sample_list", "list")
    validate(x)
    return(x)
}


#' @export
validate.sample_list <- function(x, ...) {
    assert_that(
        is.null(names(x)),
        all(vapply(x, function(x) class(x)[[1]] == "sample_single", logical(1))),
        all(vapply(x, function(x) validate(x), logical(1)))
    )
}


#' TODO
#'
#' @description
#' TODO
#'
#' @param method TODO
#' @param samples TODO
#' @param data TODO
#' @param formula TODO
#' @param n_failures TODO
#' @param fit TODO
as_draws <- function(
    method,
    samples,
    data,
    formula,
    n_failures = NULL,
    fit = NULL
) {
    x <- list(
        data = data,
        method = method,
        samples = samples,
        fit = fit,
        n_failures = n_failures,
        formula = formula
    )

    next_class <- switch(class(x$method)[[2]],
        "approxbayes" = "random",
        "condmean" = "condmean",
        "bayes" = "random"
    )

    class(x) <- c("draws", next_class, "list")
    return(x)
}


#' @export
validate.draws <- function(x, ...) {
    assert_that(
        has_class(x$data, "longdata"),
        has_class(x$method, "method"),
        has_class(x$samples, "sample_list"),
        validate(x$samples),
        is.null(x$n_failures) | is.numeric(x$n_failures),
        is.null(x$fit) | has_class(x$fit, "stanfit"),
        has_class(x$formula, "formula")
    )
}
